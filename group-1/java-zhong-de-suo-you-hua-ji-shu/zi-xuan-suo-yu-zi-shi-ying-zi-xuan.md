# 自旋锁与自适应自旋

**互斥同步对性能最大的影响是阻塞的实现**，挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作给 Java 虚拟机的并发性能带来了很大的压力。而**在许多应用上，共享数据的锁定状态只会持续很短的一段时间，为了这段时间去挂起和恢复线程并不值得。**

现在绝大多数的个人电脑和服务器都是多核处理器系统，如果物理机器有一个以上的处理器或者处理器核心，能让两个或以上的线程同时并行执行，我们就**可以让后面请求锁的那个线程“稍等一会”，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。为了让线程等待，我们只须让线程执行一个忙循环（自旋），这项技术就是所谓的**<mark style="color:blue;">**自旋锁**</mark>**。**

**自旋等待本身虽然避免了线程切换的开销，但它是要占用处理器时间的，所以如果锁被占用的时间很短，自旋等待的效果就会非常好，反之如果锁被占用的时间很长，那么自旋的线程只会白白消耗处理器资源，而不会做任何有价值的工作，这就会带来性能的浪费。**因此自旋等待的时间必须有一定的限度，<mark style="color:blue;">**如果自旋超过了限定的次数仍然没有成功获得锁，就应当使用传统的方式去挂起线程。**</mark>自旋次数的默认值是十次，用户也可以使用参数 -XX:PreBlockSpin 来自行更改。

在 JDK 6 中对自旋锁进行了优化，引入了<mark style="color:blue;">**自适应的自旋**</mark>。**自适应意味着自旋的时间不再是固定的了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。**

* 如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而允许自旋等待持续相对更长的时间，比如持续100次忙循环。
* 另一方面，如果对于某个锁，自旋很少成功获得过锁，那在以后要获取这个锁时将有可能直接省略掉自旋过程，以避免浪费处理器资源。
