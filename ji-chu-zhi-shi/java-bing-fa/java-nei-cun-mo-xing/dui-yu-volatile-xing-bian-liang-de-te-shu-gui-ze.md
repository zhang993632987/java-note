# 对于 volatile 型变量的特殊规则

当一个变量被定义成 volatile 之后，它将具备两项特性：

1. 第一项是保证此变量对所有线程的**可见性**，这里的<mark style="color:blue;">**“可见性”是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。**</mark>
2. 使用 volatile 变量的第二个语义是**禁止指令重排序优化**。

{% hint style="info" %}
## <mark style="color:blue;">提示</mark>

**volatile 变量读操作的性能消耗与普通变量几乎没有什么差别，但是写操作则可能会慢上一些，因为它需要在本地代码中插入许多**<mark style="color:blue;">**内存屏障指令**</mark>**来保证处理器不发生乱序执行。**
{% endhint %}

{% hint style="success" %}
## **指令重排序**

从硬件架构上讲，指令重排序是指处理器采用了允许将多条指令不按程序规定的顺序分开发送给各个相应的电路单元进行处理。但并不是说指令任意重排，处理器必须能正确处理指令依赖情况保障程序能得出正确的执行结果。

譬如指令 1 把地址 A 中的值加 10，指令 2 把地址 A 中的值乘以 2，指令 3 把地址 B 中的值减去 3。

* 这时指令 1 和指令 2 是有依赖的，它们之间的顺序不能重排——(A + 10) \* 2_与 A \*_ 2 + 10 显然不相等；
* 但指令 3可以重排到指令 1、2 之前或者中间，只要保证处理器执行后面依赖到 A、B 值的操作时能获取正确的 A 和 B 值即可。

所以**在同一个处理器中，重排序过的代码看起来依然是有序的。**
{% endhint %}
