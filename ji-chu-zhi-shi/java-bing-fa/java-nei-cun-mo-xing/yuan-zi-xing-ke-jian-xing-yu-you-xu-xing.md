# 原子性、可见性与有序性

## <mark style="color:blue;">原子性（Atomicity）</mark>

在 Java 中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。

## <mark style="color:blue;">可见性（Visibility）</mark>

**可见性是指当一个线程修改了共享变量的值时，其他线程能够立即得知这个修改。**

Java 内存模型是通过“**在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值**”这种依赖主内存作为传递媒介的方式来实现可见性的，无论是普通变量还是 volatile 变量都是如此。

普通变量与 volatile 变量的区别是：**volatile 的特殊规则保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。**因此我们可以说 volatile 保证了多线程操作时变量的可见性，而普通变量则不能保证这一点。因为**普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。**

**除了 volatile 之外，Java 还有两个关键字能实现可见性，它们是 synchronized 和 final：**

* 同步块的可见性是由“**对一个变量执行 unlock 操作之前，必须先把此变量同步回主内存中**”这条规则获得的。
*   final 关键字的可见性是指：**被 final 修饰的字段在构造器中一旦被初始化完成，并且构造器没有把 this 的引用传递出去，那么在其他线程中就能看见 final 字段的值。**

    > this 引用逃逸是一件很危险的事情，其他线程有可能通过这个引用访问到“初始化了一半”的对象。

## <mark style="color:blue;">有序性（Ordering）</mark>

Java 程序中天然的有序性可以总结为一句话：**如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。**

* 前半句是指“**线程内似表现为串行的语义**”（Within-Thread As-If-SerialSemantics）
* 后半句是指“**指令重排序**”现象和“**工作内存与主内存同步延迟**”现象。

Java 语言提供了 volatile 和 synchronized 两个关键字来保证线程之间操作的有序性：

* **volatile 关键字本身就包含了禁止指令重排序的语义；**
* 而 synchronized 则是由“**一个变量在同一个时刻只允许一条线程对其进行 lock 操作**”这条规则获得的，这个规则决定了**持有同一个锁的两个同步块只能串行地进入**。
