# 垃圾收集器

## Serial 收集器

这个收集器是一个**单线程**工作的收集器，但它的“单线程”的意义并不仅仅是说明它只会使用一个处理器或一条收集线程去完成垃圾收集工作，更重要的是强调在它进行垃圾收集时，必须暂停其他所有工作线程，直到它收集结束。

迄今为止，它**依然是 HotSpot 虚拟机运行在客户端模式下的默认新生代收集器**，有着优于其他收集器的地方，那就是**简单而高效**（与其他收集器的单线程相比）：

* 对于内存资源受限的环境，**它是所有收集器里额外内存消耗（Memory Footprint）最小的**；
* 对于单核处理器或处理器核心数较少的环境来说，**Serial 收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率**。

> **在用户桌面的应用场景以及近年来流行的部分微服务应用中，分配给虚拟机管理的内存一般来说并不会特别大，收集几十兆甚至一两百兆的新生代（仅仅是指新生代使用的内存，桌面应用甚少超过这个容量），垃圾收集的停顿时间完全可以控制在十几、几十毫秒，最多一百多毫秒以内，只要不是频繁发生收集，这点停顿时间对许多用户来说是完全可以接受的。**

## ParNew 收集器

**ParNew 收集器实质上是 Serial 收集器的多线程并行版本**，除了同时使用多条线程进行垃圾收集之外，其余的行为包括 Serial 收集器可用的所有控制参数、收集算法、Stop The World、对象分配规则、回收策略等都与 Serial 收集器完全一致。

> ParNew 收集器是不少运行在服务端模式下的 HotSpot 虚拟机（尤其是 JDK 7 之前的遗留系统中）首选的新生代收集器，其中有一个与功能、性能无关但其实很重要的原因是：**除了 Serial 收集器外，目前只有它能与 CMS 收集器配合工作。**
>
> **ParNew 收集器是激活 CMS 后（使用 -XX:+UseConcMarkSweepGC 选项）的默认新生代收集器。**

## Parallel Scavenge 收集器

Parallel Scavenge 收集器也是一款**新生代收集器**，它同样是**基于标记-复制算法**实现的收集器，也是**能够并行收集**的多线程收集器。

**Parallel Scavenge 收集器的特点是它的关注点与其他收集器不同，CMS 等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而 **<mark style="color:blue;">**Parallel Scavenge 收集器的目标则是达到一个可控制的吞吐量（Throughput）。**</mark>所谓吞吐量就是处理器用于运行用户代码的时间与处理器总消耗时间的比值，即：

$$
\text{吞吐量} = \frac{\text{运行用户代码时间}}{\text{运行用户代码时间} + \text{运行垃圾收集的时间}}
$$

> **停顿时间越短就越适合需要与用户交互或需要保证服务响应质量的程序，良好的响应速度能提升用户体验；**
>
> **而高吞吐量则可以最高效率地利用处理器资源，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的分析任务。**

## Serial Old 收集器

**Serial Old 是 Serial 收集器的老年代版本**，它同样是一个**单线程收集器**，**使用标记-整理算法**。

**这个收集器的主要意义是供客户端模式下的 HotSpot 虚拟机使用。**

如果**在服务端模式下**，它也可能有两种用途：

* 一种是在 JDK 5 以及之前的版本中与 Parallel Scavenge 收集器搭配使用；
* 另外一种就是**作为 CMS 收集器发生失败时的后备预案，在并发收集发生 Concurrent Mode Failure 时使用**。

## Parallel Old 收集器

**Parallel Old 是 Parallel Scavenge 收集器的老年代版本**，支持**多线程并发收集**，**基于标记-整理算法**实现。

> **在注重吞吐量或者处理器资源较为稀缺的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器这个组合。**

## CMS收集器

**CMS（Concurrent Mark Sweep）收集器是一种**<mark style="color:blue;">**以获取最短回收停顿时间为目标**</mark>**的收集器。**

CMS收集器是**基于标记-清除算法**实现的，它的运作过程分为四个步骤：

1. **初始标记（CMS initial mark）：**初始标记仅仅只是标记一下GCRoots能直接关联到的对象，速度很快；
2. **并发标记（CMS concurrent mark）：**并发标记阶段就是从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行；
3. **重新标记（CMS remark）：**重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短；
4. **并发清除（CMS concurrent sweep）：**清理删除掉标记阶段判断的已经死亡的对象，由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。

**其中初始标记、重新标记这两个步骤仍然需要“Stop The World”。**

CMS 是一款优秀的收集器，它**最主要的优点是：并发收集、低停顿。**同时，**它拥有三个主要的缺点：**

* 首先，**CMS 收集器对处理器资源非常敏感。**在并发阶段，它虽然不会导致用户线程停顿，但却会因为占用了一部分线程（或者说处理器的计算能力）而导致应用程序变慢，降低总吞吐量。
* 然后，**由于CMS收集器无法处理“浮动垃圾”（Floating Garbage），有可能出现“Concurrent Mode Failure”失败进而导致另一次完全“Stop The World”的Full GC的产生。**
* 最后，**CMS是一款基于“标记-清除”算法实现的收集器，这意味着收集结束时会有大量空间碎片产生**。空间碎片过多时，将会给大对象分配带来很大麻烦，往往会出现老年代还有很多剩余空间，但就是无法找到足够大的连续空间来分配当前对象，而不得不提前触发一次 Full GC 的情况。

> ## <mark style="color:blue;">浮动垃圾</mark>
>
> **在CMS的并发标记和并发清理阶段，用户线程是还在继续运行的，程序在运行自然就还会伴随有新的垃圾对象不断产生，**但这一部分垃圾对象是出现在标记过程结束以后，CMS无法在当次收集中处理掉它们，只好留待下一次垃圾收集时再清理掉。**这一部分垃圾就称为“浮动垃圾”。**&#x20;
>
> **由于在垃圾收集阶段用户线程还需要持续运行，那就还需要预留足够内存空间提供给用户线程使用，因此CMS收集器不能像其他收集器那样等待到老年代几乎完全被填满了再进行收集，必须预留一部分空间供并发收集时的程序运作使用。**

## Garbage First 收集器

G1 是一款主要**面向服务端应用**的垃圾收集器。

与 CMS 的“标记-清除”算法不同，**G1 从整体来看是基于“标记-整理”算法实现的收集器**，但**从局部（两个 Region 之间）上看又是基于“标记-复制”算法**实现**。这两种算法都意味着 G1 运作期间不会产生内存空间碎片，垃圾收集完成之后能提供规整的可用内存。这种特性有利于程序长时间运行，在程序为大对象分配内存时不容易因无法找到连续内存空间而提前触发下一次收集。**

### Region

在 G1 收集器出现之前的所有其他收集器，包括 CMS 在内，垃圾收集的目标范围要么是整个新生代（Minor GC），要么就是整个老年代（Major GC），再要么就是整个 Java 堆（Full GC）。而 **G1 可以面向堆内存任何部分来组成回收集（Collection Set，一般简称 CSet）进行回收，衡量标准不再是它属于哪个分代，而是哪块内存中存放的垃圾数量最多，回收收益最大**，这就是 G1 收集器的 **Mixed GC 模式**。

**G1 开创的基于 Region 的堆内存布局是它能够实现这个目标的关键。**虽然 G1 也仍是遵循分代收集理论设计的，但其堆内存的布局与其他收集器有非常明显的差异：<mark style="color:blue;">**G1 不再坚持固定大小以及固定数量的分代区域划分，而是把连续的 Java 堆划分为多个大小相等的独立区域（Region），每一个Region都可以根据需要，扮演新生代的 Eden 空间、Survivor 空间，或者老年代空间。**</mark>收集器能够对扮演不同角色的Region采用不同的策略去处理，这样无论是新创建的对象还是已经存活了一段时间、熬过多次收集的旧对象都能获取很好的收集效果。

<mark style="color:blue;">**虽然 G1 仍然保留新生代和老年代的概念，但新生代和老年代不再是固定的了，它们都是一系列区域（不需要连续）的动态集合。**</mark>G1 收集器之所以能建立可预测的停顿时间模型，是因为它<mark style="color:blue;">**将 Region 作为单次回收的最小单元，即每次收集到的内存空间都是 Region 大小的整数倍**</mark>，这样可以有计划地避免在整个Java堆中进行全区域的垃圾收集。更具体的处理思路是**让 G1 收集器去跟踪各个 Region 里面的垃圾堆积的“价值”大小，价值即回收所获得的空间大小以及回收所需时间的经验值，然后在后台维护一个优先级列表，每次根据用户设定允许的收集停顿时间（使用参数 -XX:MaxGCPauseMillis 指定，默认值是200毫秒），优先处理回收价值收益最大的那些 Region。**这种使用Region划分内存空间，以及具有优先级的区域回收方式，保证了G1收集器在有限的时间内获取尽可能高的收集效率。

> Region 中还有一类特殊的 **Humongous 区域**，专门用来存储大对象。
>
> G1 认为只要大小超过了一个 Region 容量一半的对象即可判定为大对象。每个 Region 的大小可以通过参数 -XX:G1HeapRegionSize 设定，取值范围为 1MB～32MB，且应为 2的 N 次幂。
>
> 对于那些超过了整个 Region 容量的超级大对象，将会被存放在 N 个连续的 Humongous Region 之中，G1 的大多数行为都把 Humongous Region 作为老年代的一部分来进行看待。

### 运行过程

G1收集器的运作过程大致可划分为以下四个步骤：

1. **初始标记（Initial Marking）：**仅仅只是标记一下 GC Roots 能直接关联到的对象。**这个阶段需要停顿线程，但耗时很短，而且是借用进行 Minor GC 的时候同步完成的，所以 G1 收集器在这个阶段实际并没有额外的停顿。**
2. **并发标记（Concurrent Marking）：**从 GC Roots 开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，但**可与用户程序并发执行**。
3. **最终标记（Final Marking）：对用户线程做另一个短暂的暂停**，用于处理并发阶段结束后仍遗留下来的最后那少量的 SATB 记录。
4. **筛选回收（Live Data Counting and Evacuation）：**负责更新 Region 的统计数据，<mark style="color:blue;">**对各个 Region 的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划**</mark>，可以自由选择任意多个 Region 构成回收集，然后把决定回收的那一部分 Region 的存活对象复制到空的 Region 中，再清理掉整个旧 Region 的全部空间。**这里的操作涉及存活对象的移动，是必须暂停用户线程，由多条收集器线程并行完成的。**

<mark style="color:blue;">**G1 收集器除了并发标记外，其余阶段也是要完全暂停用户线程的**</mark>**。**它**并非纯粹地追求低延迟**，官方给它设定的目标是<mark style="color:blue;">**在延迟可控的情况下获得尽可能高的吞吐量。**</mark>

> 从 G1 开始，最先进的垃圾收集器的设计导向都不约而同地变为追求**能够应付应用的内存分配速率（Allocation Rate），而不追求一次把整个Java堆全部清理干净。**这样，**应用在分配，同时收集器在收集，只要收集的速度能跟得上对象分配的速度，那一切就能运作得很完美。**
